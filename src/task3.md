## Задание 3

1. Создайте таблицу с большим количеством данных:
    ```sql
    CREATE TABLE test_cluster AS 
    SELECT 
        generate_series(1,1000000) as id,
        CASE WHEN random() < 0.5 THEN 'A' ELSE 'B' END as category,
        md5(random()::text) as data;
    ```

2. Создайте индекс:
    ```sql
    CREATE INDEX test_cluster_cat_idx ON test_cluster(category);
    ```

3. Измерьте производительность до кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    
    > Bitmap Heap Scan on test_cluster  (cost=5540.43..20137.34 rows=497033 width=39) (actual time=13.858..59.671 rows=500719 loops=1)
    > Recheck Cond: (category = 'A'::text)
    > Heap Blocks: exact=8334
    > ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..5416.17 rows=497033 width=0) (actual time=13.122..13.122 rows=500719 loops=1)
    > Index Cond: (category = 'A'::text)
    > Planning Time: 0.702 ms
    > Execution Time: 68.727 ms
    
    *Объясните результат:*
    
    До выполнения кластеризации PostgreSQL использует стратегию Bitmap Index Scan с последующим Bitmap Heap Scan. Так как значения category = 'A' распределены по таблице случайным образом, то для выполнения запроса требуется чтение большого количества heap-страниц. Это приводит к значительным накладным расходам на ввод-вывод и большому времени выполнения запроса.

4. Выполните кластеризацию:
    ```sql
    CLUSTER test_cluster USING test_cluster_cat_idx;
    ```
    
    *Результат:*
    
    Таблица test_cluster успешно кластеризована по индексу test_cluster_cat_idx. Физический порядок строк был изменён в соответствии со значениями колонки category.

5. Измерьте производительность после кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    [Вставьте план выполнения]
    
    *Объясните результат:*
    
    После выполнения кластеризации таблицы PostgreSQL продолжил использовать стратегию Bitmap Heap Scan, однако количество читаемых heap страниц значительно сократилось. Благодаря физической группировке строк по значению category, чтение данных стало более последовательным, что привело к уменьшению времени выполнения запроса, то есть кластеризация повысила производительность без изменения типа плана выполнения.

6. Сравните производительность до и после кластеризации:
    
    *Сравнение:*
    
    Кластеризация таблицы по индексу category привела к значительному снижению числа читаемых heap-страниц и уменьшению времени выполнения запроса. Это достигается за счёт физической локализации строк с одинаковыми значениями, что снижает накладные расходы на ввод-вывод и повышает эффективность последовательного чтения.